# gRPCChat

Лёгкий пример чат-приложения на Go с использованием gRPC (bidirectional streaming).

Кратко: проект содержит отдельные приложения сервера и клиента. Клиент устанавливает би-ди-поток (stream) к серверу и отправляет/принимает сообщения в реальном времени.

## Структура репозитория

- `server/` — код сервера
  - `cmd/main.go` — точка входа сервера
  - `internal/config/` — загрузка конфигурации сервера (`config.json`) 
  - `internal/funcs/` — реализация менеджера клиентов, логика приёма/отправки сообщений
  - `proto/` — сгенерированные файлы protobuf (`chat.pb.go`, `chat_grpc.pb.go`) и исходный `chat.proto`
- `client/` — простой консольный клиент
  - `cmd/main.go` — точка входа клиента
  - `internal/config/` — конфигурация клиента (`config.json`)
  - `proto/` — сгенерированные protobuf файлы (совместимы с сервером)

Файлы `go.mod` в корне `server/` и `client/` указывают используемую версию Go и зависимости (gRPC, protobuf).

## Технологии

- Go (в проекте указана версия 1.24)
- gRPC (google.golang.org/grpc)
- Protocol Buffers (google.golang.org/protobuf)

## Протокол сообщений

Файл `proto/chat.proto` определяет одно сообщение `ChatMessage` и сервис `ChatService` с методом `Chat`, который использует двунаправленный стрим:

- ChatMessage поля:
  - `from` — отправитель (ID)
  - `to` — получатель (если пусто — широковещание всем)
  - `type` — тип сообщения (`text`, `pm`, `join`, `leave`, `system` и пр.)
  - `content` — текст сообщения
  - `timestamp` — unix timestamp (int64)

Сервер реализует менеджер клиентов (`ClientManager`), который поддерживает регистрацию/отправку/отписку клиентов и рассылку сообщений по полю `to` (личные сообщения) или всем (broadcast).

## Конфигурация

- Сервер: `server/internal/config/config.json`
  - Пример:
  ```json
  { "server_port": 8000 }
  ```

- Клиент: `client/internal/config/config.json`
  - Пример:
  ```json
  {
    "id": "user0",
    "to": "",
    "server_ip": "127.0.0.1",
    "server_port": 8000
  }
  ```

ID клиента — произвольная строка, используемая для идентификации. Поле `to` можно оставить пустым для рассылки всем.

## Как запустить (Windows PowerShell)

Открыть два терминала — один для сервера, другой для клиента.

1) Запуск сервера:

```powershell
cd .\server; go run ./...
```

Ожидаемый вывод: сервер начнёт слушать порт из `server/internal/config/config.json` (по умолчанию `8000`).

2) Запуск клиента:

```powershell
cd .\client; go run ./...
```

Клиент подключится к серверу по IP/порту из `client/internal/config/config.json`, выполнит отправку системного init-сообщения с `ID` и затем войдёт в цикл чтения/отправки сообщений из консоли.

Пример взаимодействия: в клиенте вводите текст и нажимайте Enter — сообщение отправится на сервер и затем будет ретранслировано другим пользователям (если `to` пустое) или конкретному пользователю (если в `to` указан ID).

## Генерация protobuf (при необходимости)

В проекте уже есть сгенерированные файлы `.pb.go`. Чтобы пересоздать их вручную, установите protoc и плагины и выполните (примерно):

```powershell
# Установите protoc, затем из корня сервера/ клиента:
protoc --go_out=. --go-grpc_out=. proto/chat.proto
```

(на Windows путь к `protoc` должен быть в PATH). Используйте совместимые версии плагинов для Go и protobuf.

## Известные нюансы и отладка

- Если при запуске сервера пишется, что порт занят — поменяйте `server_port` в `server/internal/config/config.json`.
- Если у вас не совпадают версии protobuf/grpc (ошибки при go build), убедитесь, что `google.golang.org/grpc` и `google.golang.org/protobuf` в `go.mod` соответствуют используемым версиям плагинов protoc.

## Тестирование и локальная проверка

- Запустите сервер и два клиента с разными `id` в конфиге и проверьте, что сообщения от одного видны у другого (при пустом `to`).
- Для личных сообщений установите `to` в ID конкретного пользователя.
